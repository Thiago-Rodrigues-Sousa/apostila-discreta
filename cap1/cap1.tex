\chapter{Conceitos Preliminares}

O objetivo deste cap\'itulo \'e apresentar alguns conceitos que ser\~ao utilizados durante o todo texto. Primeiramente,
apresentaremos os conceitos de sintaxe e sem\^antica que s\~ao fundamentais na Ci\^encia da Computa\c{c}\~ao. Logo ap\'os,
apresentamos uma breve introdu\c{c}\~ao ao assistente de provas Coq, que ser\'a utilizado durante esta apostila como uma
forma de colocar a teoria em um contexto pr\'atico usando uma ferramenta computacional.

\section{Linguagens Formais}

Matematicamente, uma linguagem formal \'e um conjunto (finito ou infinito) de termos estruturados. Esses
termos s\~ao de tamanho finito e s\~ao definidos sobre um conjunto (finito) de s\'imbolos denominado \textit{alfabeto}.
A defini\c{c}\~ao de uma linguagem formal apenas descreve a estrutura de seus elementos. Por\'em, somente a especifica\c{c}\~ao
da sintaxe de uma linguagem n\~ao \'e de grande utilidade se estes n\~ao possu\'irem sem\^antica, isto \'e, uma maneira de
interpretar estes elementos de maneira a lhes atribuir um significado. 

Iremos introduzir os conceitos de sintaxe e sem\^antica de linguagens formais usando alguns exemplos.
Na se\c{c}\~ao \ref{cap1:syn}, nosso objetivo ser\'a apresentar
algumas defini\c{c}\~oes de sintaxe de linguagens simples e, posteriormente na se\c{c}\~ao \ref{cap1:sem} ser\'a apresentado como
atribuir significado aos elementos destas linguagens.

\subsection{Sintaxe}\label{cap1:syn}

Linguagens finitas podem (em princ\'ipio) ser especificadas pela enumera\c{c}\~ao de termos da linguagem; j\'a, linguagens
infinitas s\~ao usualmente descritas por um conjunto finito de regras para construir termos desta linguagem.
O estudo de linguagens formais possui uma extensiva literatura e \'e o objeto de estudo da disciplina Fundamentos Te\'oricos da Computa\c{c}\~ao.
Neste cap\'itulo, iremos apenas apresentar alguns exemplos que visam ilustrar como definir conjuntos em termos de regras.

\begin{Definition}[Sintaxe do Conjunto de Booleanos]
  O conjunto de valores Booleanos (l\'ogicos), $\mathcal{B}$, \'e um conjunto finito, que pode ser definido pelas seguintes regras:
  \[
      \begin{array}{l}
        T \in\mathcal{B}\\
        F \in\mathcal{B}
      \end{array}
  \]
\end{Definition}

Em conjunto, essas regras podem ser interpretadas como ``o conjunto de valores booleanos, $\mathcal{B}$, \'e formado apenas pelos valores 
$T$ e $F$''.
Como o conjunto de valores Booleanos \'e finito, sua defini\c{c}\~ao utilizando regras \'e imediata (basta enumerar os seus elementos). 
A pr\'oxima defini\c{c}\~ao, mostra como definir um conjunto infinito usando um n\'umero finito de regras.

\begin{Definition}[Sintaxe do Conjunto de N\'umeros Naturais]
O conjunto de termos equivalentes aos n\'umeros naturais, $\mathcal{N}$, \'e um conjunto infinito que pode ser definido pelas seguintes regras:
\[
   \begin{array}{l}
     zero \in \mathcal{N}\\
     \text{se }n \in \mathcal{N} \text{ ent\~ao }suc\,n\in\mathcal{N}
   \end{array}
\]
\end{Definition}

As regras anteriores podem ser entendidas como:
\begin{itemize}
  \item O termo $zero$ pertence ao conjunto $\mathcal{N}$;
  \item Se $n$ \'e um termo pertencente ao conjunto $\mathcal{N}$, ent\~ao o termo $suc\,n$ tamb\'em pertence a $\mathcal{N}$.
\end{itemize}
Desta forma, o conjunto de termos $\mathcal{N}$ \'e $\{zero,\,suc\,zero,\,suc\,(suc\,zero),\,...\}$. 
Apesar de j\'a termos citado que o conjunto $\mathcal{N}$ \'e equivalente ao conjunto de n\'umeros naturais, $\mathbb{N} = \{0,1,2,...\}$, 
a equival\^encia entre eles ser\'a apresentada na se\c{c}\~ao \ref{cap1:sem}.

Antes de iniciarmos a discuss\~ao sobre como atribuir sem\^antica a termos de uma linguagem, iremos apresentar mais dois exemplos de 
defini\c{c}\~oes de sintaxe.

\begin{Definition}[Sintaxe do Conjuntos de Listas]
  O conjunto de listas de elementos de um conjunto $\mathcal{T}$, $\textit{List }\mathcal{T}$, \'e definido pelas seguintes regras:
  \[
  \begin{array}{l}
    [\,] \in \textit{List }\mathcal{T}\\
    \text{se }t \in \mathcal{T} \text{ e } ts \in \textit{List }\mathcal{T}\text{ ent\~ao } t :: ts \in \textit{List }\mathcal{T}.
  \end{array}
  \]
\end{Definition}
A defini\c{c}\~ao anterior especifica que existe uma lista que n\~ao possui nenhum elemento, representada pela constante $[\,]$. Caso a lista
n\~ao seja vazia, esta deve possuir pelo menos um elemento. Dada uma lista $ts$ e um elemento $t$, a lista $t :: ts$ representa uma
lista em que o primeiro elemento \'e $t$ e o restante \'e $ts$. Denominamos por \textit{cabe\c{c}a} o primeiro elemento de uma lista
e de \textit{cauda} o restante da lista. Sendo assim, em $t :: ts$ temos que $t$ \'e a cabe\c{c}a e $ts$ a cauda dessa lista.

\begin{Example}
Alguns exemplos de listas:
\begin{itemize}
  \item $[\,]$, representa a lista vazia.
  \item $T :: [\,]$, representa uma lista com um elemento ($T$). Nesta lista, a cabe\c{c}a \'e $T$ e a cauda, $[\,]$.
  \item $F :: T :: [\,]$, representa uma lista com dois elementos, em que a cabe\c{c}a \'e $F$ e a cauda, $T :: [\,]$.
\end{itemize}
Nos exemplos anteriores todas as listas s\~ao elementos do conjunto de listas de booleanos, $\textit{List }\mathcal{B}$.
\end{Example}

Listas s\~ao definidas de maneira independente do conjunto de elementos que as formam, isto \'e, a defini\c{c}\~ao de listas
\'e polim\'orfica em rela\c{c}\~ao ao conjunto de seus elementos.
Por exemplo, o conjunto de listas sobre 
o conjunto de valores Booleanos \'e $\textit{List }\mathcal{B}=\{[\,],\,F :: [\,],\,T :: [\,],\, F :: (T :: [\,]),\, ...\}$. Por sua vez, a lista
$zero :: (suc\,\,zero) :: [\,]$ \'e uma lista pertencente ao conjunto de listas de n\'umeros naturais, $\textit{List }\mathcal{N}$.

O pr\'oximo exemplo apresenta um conjunto de termos equivalente a express\~oes aritm\'eticas envolvendo adi\c{c}\~ao e multiplica\c{c}\~ao
sobre termos de n\'umeros naturais.

\begin{Definition}[Sintaxe do Conjunto de Express\~oes Aritm\'eticas]\label{def:arithexp}
  O conjunto de termos equivalentes a express\~oes aritm\'eticas, $\mathcal{E}$, \'e definido pelas seguintes regras:
  \[
  \begin{array}{l}
    \text{se }n\in\mathcal{N}\text{, ent\~ao } \textit{const }n\in\mathcal{E}\\
    \text{se }e_1 \in \mathcal{E} \text{ e } e_2 \in \mathcal{E}\text{ ent\~ao }\textit{plus }e_1\,e_2\in\mathcal{E}\\
    \text{se }e_1 \in \mathcal{E} \text{ e } e_2 \in \mathcal{E}\text{ ent\~ao }\textit{times }e_1\,e_2\in\mathcal{E}
  \end{array}
  \]
  Informalmente, as constantes \textit{plus} e \textit{times} ir\~ao representar as opera\c{c}\~oes de soma e multiplica\c{c}\~ao; e
  o termo \textit{const n} (em que $n\in\mathcal{N}$) denota um n\'umero natural.
\end{Definition}

\begin{Example}
  Alguns exemplos de express\~oes aritm\'eticas representadas por termos de $\mathcal{E}$:
  \begin{itemize}
    \item \textit{const (suc zero)}, representa um termo que corresponde ao n\'umero $1$
    \item \textit{plus (const (suc zero)) (const (suc zero))}, representa um termo que corresponde a express\~ao $1 + 1$.
  \end{itemize}
  Apesar de ainda n\~ao termos definido formalmente a sem\^antica dos termos do conjunto $\mathcal{E}$, \'e \'util atribuir 
  uma sem\^antica ``informal'' a eles de maneira a facilitar o entendimento de sua estrutura sint\'atica.
\end{Example}

Nas defini\c{c}\~oes anteriores apresentamos a estrutura sint\'atica de quatro conjuntos de termos e, informalmente, explicitamos a equival\^encia
destes com outros conjuntos j\'a conhecidos. A pr\'oxima se\c{c}\~ao descrever\'a como atribuir significado formal 
a essas defini\c{c}\~oes sint\'aticas.

\subsection{Sem\^antica}\label{cap1:sem}

Defini\c{c}\~oes sem\^anticas associam significado a sintaxe. Formalmente, a sem\^antica de uma linguagem \'e descrita como
uma fun\c{c}\~ao que associa termos da linguagem em quest\~ao a elementos de um conjunto cujo significado \'e definido
matematicamente, como por exemplo, o conjunto dos n\'umeros naturais, $\mathbb{N}$. Idealmente, a sem\^antica de uma linguagem formal
\'e definida em termos de sua estrutura sint\'atica.

Antes de apresentarmos uma fun\c{c}\~ao sem\^antica, elementos de uma linguagem s\~ao apenas uma sequ\^encia estruturada de s\'imbolos
sem significado. Somente ap\'os a defini\c{c}\~ao de uma fun\c{c}\~ao sem\^antica podemos intepretar esses s\'imbolos de maneira 
matematicamente precisa.

Como qualquer fun\c{c}\~ao, defini\c{c}\~oes sem\^anticas devem ser especificadas em termos de seu dom\'inio e 
contra-dom\'inio\footnote{Neste ponto, assumimos que os conceitos de dom\'inio e contra-dom\'inio de fun\c{c}\~oes \'e familiar ao leitor.
Estes conceitos ser\~ao apresentados formalmente no cap\'itulo \ref{}}. As pr\'oximas defini\c{c}\~oes ilustram poss\'iveis fun\c{c}\~oes 
sem\^anticas para as linguagens descritas na se\c{c}\~ao \ref{cap1:syn}.

\begin{Definition}[Sem\^antica do Conjunto de Booleanos]
Uma poss\'ivel sem\^antica de termos do conjunto $\mathcal{B}$ \'e dada pela seguinte fun\c{c}\~ao:
\[
\begin{array}{lcl}
\llbracket T \rrbracket & = & 1\\
\llbracket F \rrbracket & = & 0\\
\end{array}
\]
Note que o dom\'inio desta fun\c{c}\~ao \'e $\mathcal{B}$ e o contra-dom\'inio o conjunto $\{0,1\}$.
\end{Definition}
Evidentemente, a fun\c{c}\~ao anterior n\~ao \'e a \'unica poss\'ivel maneira de interpretarmos termos de $\mathcal{B}$.
Outra poss\'ivel defini\c{c}\~ao seria:
\[
\begin{array}{lcl}
\llbracket T \rrbracket & = & \{k\in\mathbb{Z}\,|\,k\neq 0\}\\
\llbracket F \rrbracket & = & \{0\}\\
\end{array}
\]
Em que o termo $T$ \'e associado com o conjunto de todos os n\'umeros inteiros diferentes de $0$ e $F$ com o conjunto contendo 
o n\'umero $0$. A fun\c{c}\~ao anterior atribui uma sem\^antica para valores Booleanos similar \`a utilizada pelas linguagens 
de programa\c{c}\~ao C/C++, em que o valor verdadeiro \'e associado a qualquer inteiro n\~ao zero.

A fun\c{c}\~ao sem\^antica para n\'umeros naturais \'e mostrada na defini\c{c}\~ao seguinte.

\begin{Definition}[Sem\^antica do Conjunto de N\'umeros Naturais]
De maneira simplista, uma forma de atribuir significado aos elementos de $\mathcal{N}$ \'e associar o valor $0$ ao termo $zero\in\mathcal{N}$
e o valor $k\in\mathbb{N}$ ao termo contendo $k$ ocorr\^encias da constante $suc$. Isto pode ser definido recursivamente da seguinte maneira:
\[
\begin{array}{lcl}
\llbracket zero \rrbracket & = & 0\\
\llbracket suc\,\,n\rrbracket & = & \llbracket n \rrbracket + 1, \text{ para }n\in\mathcal{N}
\end{array}
\]
\end{Definition}

A defini\c{c}\~ao anterior \'e um exemplo de uma defini\c{c}\~ao recursiva sobre a
estrutura da sintaxe. Como a sintaxe do conjunto $\mathcal{N}$ \'e definida recursivamente, a
defini\c{c}\~ao que lhe atribui significado \'e tamb\'em recursiva. Esperamos que o leitor deste texto
seja familiar com o conceito de recurs\~ao.

Para garantir que defini\c{c}\~oes recursivas sejam consideradas fun\c{c}\~oes, estas devem obedecer dois crit\'erios:
totalidade e termina\c{c}\~ao. A totalidade especifica que a fun\c{c}\~ao deve associar todo elemento de seu dom\'inio
a um elemento no contra-dom\'inio. Uma maneira de se garantir a totalidade \'e especificar uma equa\c{c}\~ao para cada uma
das regras de forma\c{c}\~ao da sintaxe. Na defini\c{c}\~ao anterior, temos que a fun\c{c}\~ao que atribui sem\^antica a
elementos do conjunto $\mathcal{N}$ \'e total, pois esta \'e definida para todas as regras de forma\c{c}\~ao da sintaxe de 
$\mathcal{N}$. A termina\c{c}\~ao pode ser garantida permitindo que chamadas recursivas sejam feitas apenas a sub-termos.
A fun\c{c}\~ao sem\^antica de $\mathcal{N}$ possui a propriedade de termina\c{c}\~ao, pois, a cada chamada recursiva, o 
n\'umero de ocorr\^encias da constante $suc$ \'e decrescido de $1$. Como todo termo de $\mathcal{N}$ \'e finito, temos que
isso \'e suficiente para garantir a termina\c{c}\~ao desta defini\c{c}\~ao recursiva.

Para listas e express\~oes aritm\'eticas n\~ao estamos interessados em interpret\'a-las como algum objeto matem\'atico conhecido
e sim em definir fun\c{c}\~oes sobre elementos destes conjuntos. Como tanto listas quanto express\~oes s\~ao definidos recursivamente,
fun\c{c}\~oes sobre estes elementos tamb\'em ser\~ao definidas por recurs\~ao sobre a sua estrutura. Apresentaremos, como exemplo, 
defini\c{c}\~oes de duas fun\c{c}\~oes sobre listas: uma para calcular o n\'umero de elementos da lista e outra para concatenar duas listas.

\begin{Definition}[Calculando o n\'umero de elementos de uma lista]
Considere a seguinte fun\c{c}\~ao, $length$, que a partir de uma lista de elementos produz como resultado um valor $n\in\mathbb{N}$ que
corresponde ao n\'umero de elementos da lista. Temos que a fun\c{c}\~ao $length$ possuir\'a como dom\'inio o conjunto $\textit{List }\mathcal{T}$
e como contra-dom\'inio o conjunto $\mathbb{N}$.
\[
\begin{array}{lclr}
  length\,\,[\,] & = & 0 & (1)\\
  length\,\,t :: ts & = & 1 + length\,\, ts & (2)
\end{array}
\]
A defini\c{c}\~ao de $length$ constitui uma fun\c{c}\~ao pois: 1) $length$ \'e total, pois \'e definida para cada uma das regras que formam
a sintaxe de listas e; 3) termina sempre, pois, a cada passo da execu\c{c}\~ao da fun\c{c}\~ao $length$ o primeiro elemento da lista \'e
``descartado'' na chamada recursiva.
\end{Definition}

\begin{Example}
Visando exemplificar a defini\c{c}\~ao anterior, considere a tarefa de calcular o n\'umero de elementos da seguinte lista de valores
booleanos: $T :: (F :: (T :: [\,]))$. A execu\c{c}\~ao de $length\,\,(T :: (F :: (T :: [\,])))$ \'e apresentada abaixo:
\[
\begin{array}{lcl}
length\,\,(T :: (F :: (T :: [\,]))) & = & \\
1 + length\,\,(F :: (T :: [\,]))  & = & \{\text{pela equa\c{c}\~ao }(2)\}\\
1 + (1 + length\,\,(T :: [\,]))  & = & \{\text{pela equa\c{c}\~ao }(2)\}\\
1 + (1 + (1 + length\,\,[\,]))  & = & \{\text{pela equa\c{c}\~ao }(2)\}\\
1 + (1 + (1 + 0))  & = & \{\text{pela equa\c{c}\~ao }(1)\}\\
3                  &   & 
\end{array}
\]
\end{Example}

Note que a execu\c{c}\~ao simplesmente reescreve a express\~ao de acordo com as equa\c{c}\~oes que definem a fun\c{c}\~ao $length$, ou seja, por
exemplo, o resultado de executar $length\,\,(T :: [\,])$  \'e $1 + length [\,]$, de acordo com a equa\c{c}\~ao $(2)$ de $length$.

A opera\c{c}\~ao de concatenar duas listas consiste em formar uma nova lista que consiste da segunda justaposta ao final da primeira. Por exemplo,
o resultado de concatenar a lista $T :: F :: [\,]$ com a lista $F :: F :: [\,]$ \'e a lista $T :: F :: F :: F :: [\,]$.

\begin{Definition}[Concatena\c{c}\~ao de listas]\label{def:concat:lists}
 A defini\c{c}\~ao recursiva seguinte calcula a concatena\c{c}\~ao de duas listas fornecidas como par\^ametro. 
 \[
  \begin{array}{lclr}
    [\,] \text{ ++ } ys & = & ys & (1)\\
    (x :: xs) \text{ ++ } ys & = & x :: (xs \text{ ++ } ys) & (2)
  \end{array}
  \]
Intutitivamente, a concatena\c{c}\~ao \'e definida sobre a estrutura sint\'atica da lista fornecida como primeiro par\^ametro. A equa\c{c}\~ao 
$(1)$ especifica que se a primeira lista \'e igual a $[\,]$, ent\~ao o resultado da concatena\c{c}\~ao \'e a segunda lista. Por sua vez,
a equa\c{c}\~ao $(2)$ diz que caso a primeira lista n\~ao seja vazia, ent\~ao o resultado \'e inserir o primeiro elemento no in\'icio da lista
resultante de se concatenar a cauda da primeira lista com a segunda.
\end{Definition}

\begin{Example}
Apresentaremos, passo a passo, a execu\c{c}\~ao da fun\c{c}\~ao de concatena\c{c}\~ao para as listas $T :: F :: [\,]$ e $F :: F :: [\,]$.
\[
\begin{array}{lcl}
(T :: F :: [\,]) \text{ ++ } (F :: F ::[\,]) & = & \\
T :: ((F :: [\,]) \text{ ++ } (F :: F ::[\,])) & = & \text{pela equa\c{c}\~ao }(2)\\
T :: (F :: ([\,] \text{ ++ } (F :: F ::[\,])) & = & \text{pela equa\c{c}\~ao }(2)\\
T :: (F :: (F :: F ::[\,])) & = & \text{pela equa\c{c}\~ao }(1)\\
\end{array}
\]
\end{Example}

As defini\c{c}\~oes apresentadas nesta se\c{c}\~ao s\~ao todas pass\'iveis de implementa\c{c}\~ao em qualquer linguagem de programa\c{c}\~ao
funcional. Neste texto, optaremos pelo assistente de provas Coq para este fim. A se\c{c}\~ao \ref{cap1:coq} apresenta, de maneira suscinta, 
os conceitos necess\'arios de Coq para descri\c{c}\~ao de sintaxe, sem\^antica e fun\c{c}\~oes recursivas sobre a estrutura sint\'atica de termos.

\subsection{Exerc\'icios}

\begin{enumerate}
  \item Apresente a execu\c{c}\~ao passo a passo das seguintes express\~oes:
  \begin{enumerate}
    \item $\llbracket suc (suc (suc\,\,zero))\rrbracket$ 
    \item $length (zero :: zero :: [\,])$
    \item $(zero :: (suc\,\, zero) ::[\,])\text{++}((suc\,\,zero) :: zero :: [\,])$
  \end{enumerate}
  \item Na defini\c{c}\~ao \ref{def:concat:lists} foi apresentada uma defini\c{c}\~ao recursiva para a opera\c{c}\~ao de concatena\c{c}\~ao de
        duas listas, por\'em n\~ao foi apresentada nenhuma justificativa do porqu\^e esta pode ser considerada uma fun\c{c}\~ao. Justifique
        porqu\^e a concatena\c{c}\~ao \'e uma fun\c{c}\~ao usando os conceitos de totalidade e termina\c{c}\~ao.
  \item Apresente uma defini\c{c}\~ao recursiva que calcula o valor de uma express\~ao aritm\'etica (defini\c{c}\~ao \ref{def:arithexp}).
        Sua solu\c{c}\~ao deve possuir como dom\'inio o conjunto $\mathcal{E}$ e como contra-dom\'inio o conjunto $\mathbb{N}$. Para isso, 
        interprete as constantes \textit{plus} e \textit{times} como as opera\c{c}\~oes de adi\c{c}\~ao e multiplica\c{c}\~ao, respectivamente; e
        a constante \textit{const n} deve ser interpretada como um valor num\'erico pertencente ao conjunto dos n\'umeros naturais, $\mathbb{N}$.
  \item A defini\c{c}\~ao apresentada por voc\^e no item anterior constitui uma fun\c{c}\~ao? Justifique em termos dos conceitos de totalidade
        e termina\c{c}\~ao, apresentados na se\c{c}\~ao \ref{cap1:sem}.
  \item O objetivo deste exerc\'icio \'e explicar o porqu\^e defini\c{c}\~oes recursivas que n\~ao atendem os crit\'erios de totalidade e 
        termina\c{c}\~ao n\~ao podem ser consideradas fun\c{c}\~oes. 
        Para isso, apresente exemplos de defini\c{c}\~oes recursivas que: 1) n\~ao atendem o crit\'erio de 
        totalidade e 2) n\~ao atendem o crit\'erio de termina\c{c}\~ao. Em ambos os casos, justifique porqu\^e estas n\~ao podem ser 
        fun\c{c}\~oes.        
\end{enumerate}

\section{Introdu\c{c}\~ao ao Assistente de Provas Coq}\label{cap1:coq}

Um assistente de provas \'e uma linguagem de programa\c{c}\~ao que permite a elabora\c{c}\~ao de programas e provas matem\'aticas.
Neste trabalho, n\~ao pretendemos de forma alguma fornecer um tutorial para a utiliza\c{c}\~ao de Coq. Existem diversos bons livros
para isso, como por exemplo \cite{coqart,Pierce12,Coqrefman}. Neste texto, descreveremos apenas os recursos necess\'arios de Coq para
o aprendizado dos conceitos desta apostila sem mencionar os detalhes te\'oricos necess\'arios para uma completa compreens\~ao dessa ferramenta.

\subsection{Representando Sintaxe em Coq}

Representaremos defini\c{c}\~oes de sintaxe de termos utilizando tipos de dados em Coq. O trecho de c\'odigo Coq a seguir ilustra um
tipo de dados que denota o conjunto $\mathcal{B}$ de valores booleanos.

\begin{lstlisting}
Inductive Bool : Set :=
   | T : Bool
   | F : Bool.
\end{lstlisting}

Novos tipos de dados em Coq s\~ao declarados utilizando a palavra chave \texttt{Inductive}. Al\'em do nome do novo tipo (\texttt{Bool}), sempre
devemos especificar o universo ao qual o tipo pertence (no trecho anterior, o tipo \texttt{Bool} \'e definido como sendo do universo 
\texttt{Set}, que representam valores sobre os quais podemos efetuar c\'alculos) e os construtores de valores deste tipo. Construtores s\~ao
a terminologia utilizada em Coq para representar regras de forma\c{c}\~ao de elementos de um dado tipo. No exemplo anterior, o tipo \texttt{Bool}
possui dois construtores: \texttt{T} e \texttt{F}, que representam os \'unicos elementos deste tipo.

A defini\c{c}\~ao da sintaxe de n\'umeros naturais, conjunto $\mathcal{N}$, \'e feita de maneira similar:
\begin{lstlisting}
Inductive Nat : Set :=
   | Zero : Nat
   | Suc  : Nat -> Nat.
\end{lstlisting}
O tipo \texttt{Nat} \'e definido usando dois construtores. O primeiro, \texttt{Zero}, representa a constante $zero\in\mathcal{N}$. O construtor
\texttt{Suc} \'e o primeiro exemplo de um tipo funcional em Coq. O tipo \texttt{Nat -> Nat} denota uma fun\c{c}\~ao que recebe como par\^ametro
um valor de tipo \texttt{Nat} e retorna um valor de \texttt{Nat}. Sendo assim, o constructor \texttt{Suc} recebe como par\^ametro um valor de
tipo \texttt{Nat} e retorna outro valor de \texttt{Nat}. Devido ao tipo de \texttt{Suc}, temos que \texttt{Nat} \'e um tipo recursivo, isto \'e,
ele \'e definido em termos de si pr\'oprio. Como exemplo, qualquer valor de \texttt{Nat} que seja formado pela constante \texttt{Suc}, deve
possuir como subtermo outro valor de \texttt{Nat}. O n\'umero $3$ corresponde
 ao seguinte elemento de $\mathcal{N}$: $suc\,\,(suc\,\,(suc\,\,zero))$ e a seguinte defini\c{c}\~ao em Coq:
\begin{lstlisting}
Definition three : Nat := Suc (Suc (Suc Zero)).
\end{lstlisting}
A palavra chave \texttt{Definition} permite a defini\c{c}\~ao de fun\c{c}\~oes n\~ao recursivas sobre tipos quaisquer. No trecho de c\'odigo
anterior, \texttt{three} representa a fun\c{c}\~ao constante que sempre retorna \texttt{Suc (Suc (Suc Zero))} como resultado.
Por\'em, como \texttt{five} (apresentada a seguir) nos mostra, podemos utilizar uma defini\c{c}\~ao para criar outra, desde que isso 
n\~ao envolva recurs\~ao.
\begin{lstlisting}
Definition five : Nat := Suc (Suc three).
\end{lstlisting}

A seguinte defini\c{c}\~ao denota o conjunto de listas sobre um certo tipo \texttt{T}, ou seja, c\'odigo Coq para o conjunto 
\textit{List $\mathcal{T}$}. 
\begin{lstlisting}
Inductive List (T : Set) : Set :=
  | nil  : List T
  | cons : T -> List T -> List T.
\end{lstlisting}
No c\'odigo Coq correpondente a este cap\'itulo, definimos algumas nota\c{c}\~oes para facilitar a cria\c{c}\~ao de valores de tipo lista.
Estas nota\c{c}\~oes permitem escrever \texttt{[]} ao inv\'es de \texttt{nil} e \texttt{t :: ts} ao inv\'es de \texttt{Cons t ts}. Como
exemplo, as seguintes listas s\~ao id\^enticas, por\'em, \texttt{myList} usa as nota\c{c}\~oes e \texttt{myList'} usa os construtores
definidos para o tipo \texttt{List}.
\begin{lstlisting}
Definition myList' : List Bool := Cons T (Cons F nil).
Definition myList : List Bool := T :: F :: [].
\end{lstlisting}

Finalmente, o seguinte tipo define a  sintaxe de express\~oes aritm\'eticas, equivalente ao conjunto $\mathcal{E}$:
\begin{lstlisting}
Inductive Exp : Set :=
  | Const : Nat -> Exp
  | Plus  : Exp -> Exp -> Exp
  | Times : Exp -> Exp -> Exp.
\end{lstlisting}
Assim como fizemos para listas, definidos nota\c{c}\~oes para facilitar a escrita de valores do tipo \texttt{Exp} que s\~ao ilustradas a seguir:
\begin{lstlisting}
Definition myExp' : Exp := 
      Plus (Const Zero) (Const (Suc Zero)).
Definition myExp : Exp := 
      (Const Zero) :+ (Const (Suc Zero)).
\end{lstlisting}
As nota\c{c}\~oes definidas para express\~oes visam evitar o uso dos construtores \texttt{Plus} e \texttt{Times} substituindo-os pelos s\'imbolos
\texttt{:+} e \texttt{:*}, respectivamente.

\subsection{Representanto Sem\^antica em Coq}

Conforme apresentado na se\c{c}\~ao \ref{cap1:sem}, defini\c{c}\~oes sem\^anticas s\~ao especificadas por recurs\~ao sobre a estrutura sint\'atica
dos termos do conjunto em quest\~ao. Al\'em disso, para que defini\c{c}\~oes recursivas sejam consideradas fun\c{c}\~oes estas devem atender
os crit\'erios de totalidade e termina\c{c}\~ao.

Em Coq, toda fun\c{c}\~ao (recursiva ou n\~ao) deve obedecer os crit\'erios de totalidade e termina\c{c}\~ao. Se uma defini\c{c}\~ao 
n\~ao atender esses crit\'erios, ser\'a emitida uma mensagem de erro. Essas restri\c{c}\~oes s\~ao fundamentais para que Coq possa ser 
utilizado como um verificador de provas.

A primeira defini\c{c}\~ao sem\^antica apresentada ser\'a para o tipo
\texttt{Bool}. Como vimos na sec\c{c}\~ao \ref{cap1:sem}, a
fun\c{c}\~ao sem\^antica para o conjunto $\mathcal{B}$ \'e tal que
ao valor $T$ atribui-se $1$ e $0$ para $F$, ou seja, esta fun\c{c}\~ao
possui como dom\'inio o conjunto de valores booleanos, $\mathcal{B}$
e contra-dom\'inio o conjunto dos n\'umeros naturais, $\mathbb{N}$. 
A seguinte fun\c{c}\~ao apresenta a sem\^antica para o tipo \texttt{Bool}:
\begin{lstlisting}
Definition BoolSem (b : Bool) : nat :=
  match b with
    | T => 1
    | F => 0
  end.
\end{lstlisting}
O c\'odigo anterior mostra a fun\c{c}\~ao \texttt{BoolSem} que recebe
como par\^ametro um valor de tipo \texttt{Bool}, de nome \texttt{b}, e
retorna um n\'umero natural, um valor de tipo \texttt{nat}. Como a
sem\^antica de valores booleanos depende de sua sintaxe ( $1$ para $T$
e $0$ para $F$) devemos usar casamento de padr\~ao para analisar a
estrutura sint\'atica do par\^ametro \texttt{b} para, ent\~ao,
retornar o resultado apropriado. O casamento de padr\~ao, em Coq, \'e
feito usando a constru\c{c}\~ao \texttt{match}, que permite definir um
conjunto de equa\c{c}\~oes, uma para cada possibilidade sint\'atica do
valor analisado. Note que, Coq exige que todo \texttt{match}
obede\c{c}a o crit\'erio de totalidade, isto é, as equa\c{c}\~oes
devem cobrir todas as possibilidades do tipo do valor analisado.

Para a fun\c{c}\~ao \texttt{BoolSem} a totalidade \'e facilmente
atingida estabelecendo uma equa\c{c}\~ao para cada um dos valores de
\texttt{Bool}.

O pr\'oximo exemplo define a sem\^antica do tipo \texttt{Nat}. Como
este tipo \'e recursivo, sua fun\c{c}\~ao sem\^antica tamb\'em ser\'a.
Em Coq, definimos fun\c{c}\~oes recursivas utilizando o comando
\texttt{Fixpoint}.
 
\begin{lstlisting}
Fixpoint NatSem (n : Nat) : nat :=
  match n with
    | Zero  => 0
    | Suc n' => 1 + NatSem n'
  end.
\end{lstlisting}
Como o comando \texttt{Fixpoint} permite defini\c{c}\~oes recursivas,
Coq exige que estas satisfa\c{c}am os crit\'erios de termina\c{c}\~ao
e totalidade. Note que o \texttt{match} que define a fun\c{c}\~ao
\texttt{NatSem} \'e total (pois, todo valor de \texttt{Nat} ou \'e
igual a \texttt{Zero} ou igual \texttt{Suc n}, para algum \texttt{n}
de tipo \texttt{Nat}) e termina, pois a chamada recursiva de
\texttt{NatSem} diminui o n\'umero de constantes \texttt{Suc}
presentes no termo.

Na equa\c{c}\~ao para a constante \texttt{Suc} em \texttt{NatSem},
temos a presen\c{a} de uma vari\'avel no lado esquerdo. Durante o
casamento de padr\~ao, vari\'aveis s\~ao associadas a valores. Como um
exemplo, considere executar \texttt{NatSem (Suc (Suc Zero))}. Neste
caso, temos que a equa\c{c}\~ao:
\begin{lstlisting}
Suc n' => 1 + NatSem n'
\end{lstlisting}
ser\'a executada. Durante o processo de casamento de padr\~ao, temos
que o valor de n' ser\'a \texttt{Suc Zero}, j\'a que o termo analisado
pelo \texttt{match} foi \texttt{Suc (Suc Zero)}. Note que a estrutura
do padr\~ao da equa\c{c}\~ao (\texttt{Suc n'})  faz com que o subtermo
\texttt{Suc Zero} de \texttt{Suc (Suc Zero)} seja atribu\'ido \`a
vari\'avel \texttt{n'}.

As fun\c{c}\~oes \texttt{length} e \texttt{app} definem as
opera\c{c}\~oes de c\'alculo do n\'umero de elementos e
concatena\c{c}\~ao sobre listas. O c\'odigo Coq correspondente a ambas
\'e apresentado a seguir:

\begin{lstlisting}
Fixpoint length {T} (l : List T) : nat :=
  match l with
    | []      => 0
    | t :: ts => 1 + length ts
  end.

Fixpoint app {T} (l l' : List T) : List T :=
  match l with
    | []      => l'
    | t :: ts => t :: (app ts l')
  end.
\end{lstlisting}
A defini\c{c}\~ao destas fun\c{c}\~oes \'e simplesmente uma
tradu\c{c}\~ao do que foi apresentado na se\c{c}\~ao \ref{cap1:sem}
para Coq.

Com isso, terminamos nossa introdu\c{c}\~ao \`a utiliza\c{c}\~ao de
Coq para definir sintaxe e sem\^antica de linguagens formais. Nos
capítulos seguintes, maiores detalhes da ferramenta ser\~ao
apresentados de forma a podermos utiliz\'a-la como um recurso
did\'atico adicional para o aprendizado do conte\'udo de Matem\'atica Discreta.

\subsection{Exerc\'icios}

\begin{enumerate}
    \item Apresente uma fun\c{c}\~ao em Coq que calcula o valor de uma express\~ao aritm\'etica (defini\c{c}\~ao \ref{def:arithexp}).
        Sua solu\c{c}\~ao deve possuir como par\^ametro um valor de
        tipo \texttt{Exp}. O tipo de retorno de sua fun\c{c}\~ao deve
        ser \texttt{nat}, o tipo correspondente a n\'umeros naturais
        em Coq. 
    \item Defina fun\c{c}\~oes que, a partir de uma lista fornecida
      como par\^ametro, retornem a cabe\c{c}a e a cauda desta.
\end{enumerate}

\section{Notas Bibliogr\'aficas}

Conceitos de sintaxe e sem\^antica s\~ao pervasivos na Ci\^encia da
Computa\c{c}\~ao. Estes s\~ao presentes em livros de sem\^antica
formal \cite{Winskel93}, teoria de linguagens \cite{Hopcroft06} e
constru\c{c}\~ao de compiladores \cite{Aho86}.

Coq \'e, atualmente, o mais maduro assistente de provas baseado em
teoria de tipos e \'e empregado com sucesso em diversos projetos
industriais e cient\'ificos. Diversos livros fornecem
uma introdu\c{c}\~ao \`a utiliza\c{c}\~ao dessa ferramenta al\'em dos
prop\'ositos deste texto. O leitor interessado pode aprofundar seus
conhecimentos usando \cite{coqart,Pierce12,Coqrefman}.
